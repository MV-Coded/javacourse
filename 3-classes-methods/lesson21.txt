Разница в результатах между циклом (1) и явными вызовами (2) объясняется тем, 
что в Java при работе с массивом объектов Number[] и использовании цикла for-each происходит автоматическое приведение типов на этапе компиляции. 
В цикле (1) переменная n имеет статический тип Number, 
поэтому компилятор выбирает метод printNum(Number n), 
который вызывается для каждого элемента массива независимо от его фактического типа (Integer, Float или Double). 
Это приводит к одинаковому выводу "Number=..." для всех элементов.

В случае явных вызовов (2), компилятор видит фактичесный тип передаваемого аргумента: 
new Integer(1) — это Integer, 
11 — это int (примитив), 
1.11f — это float, 
11.11 — это double. 
Поэтому он выбирает наиболее подходящую перегруженную версию метода printNum на основе статического типа аргумента: 
printNum(Integer) для первого, 
printNum(int) для второго, 
printNum(float) для третьего и 
printNum(double) для четвертого. 
В результате выводится соответствующее представление типа: "Integer = 1", "int = 11", "float = 1.11", "Number=11.11" 
(последний вызывает printNum(Number) из-за того, что double не имеет точного совпадения, а Number является общим суперклассом, 
хотя в данном случае, судя по коду, printNum(double) не определен, поэтому используется printNum(Number)).

Таким образом, ключевое отличие заключается в том, что в цикле (1) используется динамический тип элемента массива, 
но статический тип переменной цикла (Number) определяет выбор перегруженного метода, 
тогда как в (2) статический тип каждого конкретного аргумента позволяет компилятору выбрать наиболее специфичную перегрузку.
